{"ast":null,"code":"import { extend, isNullOrUndefined } from '../util';\nimport { ParserBase as parser } from './parser-base';\nimport { IntlBase as base } from './intl-base';\nvar formatRegex = /(^[ncpa]{1})([0-1]?[0-9]|20)?$/i;\nvar parseRegex = /^([^0-9]*)(([0-9,]*[0-9]+)(\\.[0-9]+)?)([Ee][+-]?[0-9]+)?([^0-9]*)$/;\nvar groupRegex = /,/g;\nvar latnDecimalRegex = /^[0-9]*(\\.[0-9]+)?$/;\nvar keys = ['minusSign', 'infinity'];\n/**\n * Module for Number Parser.\n * @private\n */\n\nvar NumberParser =\n/** @class */\nfunction () {\n  function NumberParser() {}\n  /**\n   * Returns the parser function for given skeleton.\n   * @param {string} -  Specifies the culture name to be which formatting.\n   * @param {NumberFormatOptions} - Specific the format in which number  will parsed.\n   * @param {cldr} - Specifies the global cldr data collection.\n   * @return Function.\n   */\n\n\n  NumberParser.numberParser = function (culture, option, cldr) {\n    var _this = this;\n\n    var dependable = base.getDependables(cldr, culture, '', true);\n    var parseOptions = {\n      custom: true\n    };\n    var numOptions;\n\n    if (base.formatRegex.test(option.format) || !option.format) {\n      extend(parseOptions, base.getProperNumericSkeleton(option.format || 'N'));\n      parseOptions.custom = false;\n    } else {\n      extend(parseOptions, base.customFormat(option.format, null, null));\n    }\n\n    numOptions = parser.getCurrentNumericOptions(dependable.parserObject, parser.getNumberingSystem(cldr), true);\n    parseOptions.symbolRegex = parser.getSymbolRegex(Object.keys(numOptions.symbolMatch)); // tslint:disable-next-line:no-any\n\n    parseOptions.infinity = numOptions.symbolNumberSystem[keys[1]];\n    var symbolpattern = base.getSymbolPattern(parseOptions.type, numOptions.numberSystem, dependable.numericObject, parseOptions.isAccount);\n\n    if (symbolpattern) {\n      symbolpattern = symbolpattern.replace(/\\u00A4/g, base.defaultCurrency);\n      var split = symbolpattern.split(';');\n      parseOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, '');\n      parseOptions.pData = base.getFormatData(split[0], true, '');\n    }\n\n    return function (value) {\n      return _this.getParsedNumber(value, parseOptions, numOptions);\n    };\n  };\n  /**\n   * Returns parsed number for the provided formatting options\n   * @param {string} value\n   * @param {NumericParts} options\n   * @param {NumericOptions} numOptions\n   * @returns {number}\n   */\n\n\n  NumberParser.getParsedNumber = function (value, options, numOptions) {\n    var isNegative;\n    var isPercent;\n    var tempValue;\n    var lead;\n    var end;\n    var ret;\n\n    if (value.indexOf(options.infinity) !== -1) {\n      return Infinity;\n    } else {\n      value = parser.convertValueParts(value, options.symbolRegex, numOptions.symbolMatch);\n      value = parser.convertValueParts(value, numOptions.numberParseRegex, numOptions.numericPair);\n\n      if (value.indexOf('.') === 0) {\n        value = '0' + value;\n      }\n\n      var matches = value.match(parseRegex);\n\n      if (isNullOrUndefined(matches)) {\n        return NaN;\n      }\n\n      lead = matches[1];\n      tempValue = matches[2];\n      var exponent = matches[5];\n      end = matches[6];\n      isNegative = options.custom ? lead === options.nData.nlead && end === options.nData.nend : lead.indexOf(options.nData.nlead) !== -1 && end.indexOf(options.nData.nend) !== -1;\n      isPercent = isNegative ? options.nData.isPercent : options.pData.isPercent;\n      tempValue = tempValue.replace(groupRegex, '');\n\n      if (exponent) {\n        tempValue += exponent;\n      }\n\n      ret = +tempValue;\n\n      if (options.type === 'percent' || isPercent) {\n        ret = ret / 100;\n      }\n\n      if (options.custom || options.fractionDigits) {\n        ret = parseFloat(ret.toFixed(options.custom ? isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits : options.fractionDigits));\n      }\n\n      if (isNegative) {\n        ret *= -1;\n      }\n\n      return ret;\n    }\n  };\n\n  return NumberParser;\n}();\n\nexport { NumberParser };","map":{"version":3,"sources":["/Users/jay/node_modules/@syncfusion/ej2-base/src/intl/number-parser.js"],"names":["extend","isNullOrUndefined","ParserBase","parser","IntlBase","base","formatRegex","parseRegex","groupRegex","latnDecimalRegex","keys","NumberParser","numberParser","culture","option","cldr","_this","dependable","getDependables","parseOptions","custom","numOptions","test","format","getProperNumericSkeleton","customFormat","getCurrentNumericOptions","parserObject","getNumberingSystem","symbolRegex","getSymbolRegex","Object","symbolMatch","infinity","symbolNumberSystem","symbolpattern","getSymbolPattern","type","numberSystem","numericObject","isAccount","replace","defaultCurrency","split","nData","getFormatData","pData","value","getParsedNumber","options","isNegative","isPercent","tempValue","lead","end","ret","indexOf","Infinity","convertValueParts","numberParseRegex","numericPair","matches","match","NaN","exponent","nlead","nend","fractionDigits","parseFloat","toFixed","maximumFractionDigits"],"mappings":"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","sourcesContent":["import { extend, isNullOrUndefined } from '../util';\nimport { ParserBase as parser } from './parser-base';\nimport { IntlBase as base } from './intl-base';\nvar formatRegex = /(^[ncpa]{1})([0-1]?[0-9]|20)?$/i;\nvar parseRegex = /^([^0-9]*)(([0-9,]*[0-9]+)(\\.[0-9]+)?)([Ee][+-]?[0-9]+)?([^0-9]*)$/;\nvar groupRegex = /,/g;\nvar latnDecimalRegex = /^[0-9]*(\\.[0-9]+)?$/;\nvar keys = ['minusSign', 'infinity'];\n/**\n * Module for Number Parser.\n * @private\n */\nvar NumberParser = /** @class */ (function () {\n    function NumberParser() {\n    }\n    /**\n     * Returns the parser function for given skeleton.\n     * @param {string} -  Specifies the culture name to be which formatting.\n     * @param {NumberFormatOptions} - Specific the format in which number  will parsed.\n     * @param {cldr} - Specifies the global cldr data collection.\n     * @return Function.\n     */\n    NumberParser.numberParser = function (culture, option, cldr) {\n        var _this = this;\n        var dependable = base.getDependables(cldr, culture, '', true);\n        var parseOptions = { custom: true };\n        var numOptions;\n        if ((base.formatRegex.test(option.format)) || !(option.format)) {\n            extend(parseOptions, base.getProperNumericSkeleton(option.format || 'N'));\n            parseOptions.custom = false;\n        }\n        else {\n            extend(parseOptions, base.customFormat(option.format, null, null));\n        }\n        numOptions = parser.getCurrentNumericOptions(dependable.parserObject, parser.getNumberingSystem(cldr), true);\n        parseOptions.symbolRegex = parser.getSymbolRegex(Object.keys(numOptions.symbolMatch));\n        // tslint:disable-next-line:no-any\n        parseOptions.infinity = numOptions.symbolNumberSystem[keys[1]];\n        var symbolpattern = base.getSymbolPattern(parseOptions.type, numOptions.numberSystem, dependable.numericObject, parseOptions.isAccount);\n        if (symbolpattern) {\n            symbolpattern = symbolpattern.replace(/\\u00A4/g, base.defaultCurrency);\n            var split = symbolpattern.split(';');\n            parseOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, '');\n            parseOptions.pData = base.getFormatData(split[0], true, '');\n        }\n        return function (value) {\n            return _this.getParsedNumber(value, parseOptions, numOptions);\n        };\n    };\n    /**\n     * Returns parsed number for the provided formatting options\n     * @param {string} value\n     * @param {NumericParts} options\n     * @param {NumericOptions} numOptions\n     * @returns {number}\n     */\n    NumberParser.getParsedNumber = function (value, options, numOptions) {\n        var isNegative;\n        var isPercent;\n        var tempValue;\n        var lead;\n        var end;\n        var ret;\n        if (value.indexOf(options.infinity) !== -1) {\n            return Infinity;\n        }\n        else {\n            value = parser.convertValueParts(value, options.symbolRegex, numOptions.symbolMatch);\n            value = parser.convertValueParts(value, numOptions.numberParseRegex, numOptions.numericPair);\n            if (value.indexOf('.') === 0) {\n                value = '0' + value;\n            }\n            var matches = value.match(parseRegex);\n            if (isNullOrUndefined(matches)) {\n                return NaN;\n            }\n            lead = matches[1];\n            tempValue = matches[2];\n            var exponent = matches[5];\n            end = matches[6];\n            isNegative = options.custom ? ((lead === options.nData.nlead) && (end === options.nData.nend)) :\n                ((lead.indexOf(options.nData.nlead) !== -1) && (end.indexOf(options.nData.nend) !== -1));\n            isPercent = isNegative ?\n                options.nData.isPercent :\n                options.pData.isPercent;\n            tempValue = tempValue.replace(groupRegex, '');\n            if (exponent) {\n                tempValue += exponent;\n            }\n            ret = +tempValue;\n            if (options.type === 'percent' || isPercent) {\n                ret = ret / 100;\n            }\n            if (options.custom || options.fractionDigits) {\n                ret = parseFloat(ret.toFixed(options.custom ?\n                    (isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits) : options.fractionDigits));\n            }\n            if (isNegative) {\n                ret *= -1;\n            }\n            return ret;\n        }\n    };\n    return NumberParser;\n}());\nexport { NumberParser };\n"]},"metadata":{},"sourceType":"module"}
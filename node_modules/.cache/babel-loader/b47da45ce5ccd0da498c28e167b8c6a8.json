{"ast":null,"code":"import { CompressedStreamWriter } from './compression-writer';\nimport { Save } from '@syncfusion/ej2-file-utils';\nvar CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\n\nvar ZipArchive =\n/** @class */\nfunction () {\n  /**\n   * constructor for creating ZipArchive instance\n   */\n  function ZipArchive() {\n    if (CRC32TABLE.length === 0) {\n      ZipArchive.initCrc32Table();\n    }\n\n    this.files = [];\n    this.level = 'Normal';\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n\n  Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n    /**\n     * gets compression level\n     */\n    get: function () {\n      return this.level;\n    },\n\n    /**\n     * sets compression level\n     */\n    set: function (level) {\n      this.level = level;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchive.prototype, \"length\", {\n    /**\n     * gets items count\n     */\n    get: function () {\n      if (this.files === undefined) {\n        return 0;\n      }\n\n      return this.files.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * add new item to archive\n   * @param {ZipArchiveItem} item - item to be added\n   * @returns {void}\n   */\n\n  ZipArchive.prototype.addItem = function (item) {\n    if (item === null || item === undefined) {\n      throw new Error('ArgumentException: item cannot be null or undefined');\n    }\n\n    for (var i = 0; i < this.files.length; i++) {\n      var file = this.files[i];\n\n      if (file instanceof ZipArchiveItem) {\n        if (file.name === item.name) {\n          throw new Error('item with same name already exist');\n        }\n      }\n    }\n\n    this.files.push(item);\n  };\n  /**\n   * add new directory to archive\n   * @param directoryName directoryName to be created\n   * @returns {void}\n   */\n\n\n  ZipArchive.prototype.addDirectory = function (directoryName) {\n    if (directoryName === null || directoryName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (directoryName.length === 0) {\n      throw new Error('ArgumentException: string cannot be empty');\n    }\n\n    if (directoryName.slice(-1) !== '/') {\n      directoryName += '/';\n    }\n\n    if (this.files.indexOf(directoryName) !== -1) {\n      throw new Error('item with same name already exist');\n    }\n\n    this.files.push(directoryName);\n  };\n  /**\n   * gets item at specified index\n   * @param {number} index - item index\n   * @returns {ZipArchiveItem}\n   */\n\n\n  ZipArchive.prototype.getItem = function (index) {\n    if (index >= 0 && index < this.files.length) {\n      return this.files[index];\n    }\n\n    return undefined;\n  };\n  /**\n   * determines whether an element is in the collection\n   * @param {string | ZipArchiveItem} item - item to search\n   * @returns {boolean}\n   */\n\n\n  ZipArchive.prototype.contains = function (item) {\n    return this.files.indexOf(item) !== -1 ? true : false;\n  };\n  /**\n   * save archive with specified file name\n   * @param {string} fileName save archive with specified file name\n   * @returns {Promise<ZipArchive>}\n   */\n\n\n  ZipArchive.prototype.save = function (fileName) {\n    if (fileName === null || fileName === undefined || fileName.length === 0) {\n      throw new Error('ArgumentException: fileName cannot be null or undefined');\n    }\n\n    if (this.files.length === 0) {\n      throw new Error('InvalidOperation');\n    }\n\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal(fileName, false).then(function () {\n        resolve(zipArchive);\n      });\n    });\n  };\n  /**\n   * Save archive as blob\n   * @return {Promise<Blob>}\n   */\n\n\n  ZipArchive.prototype.saveAsBlob = function () {\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal('', true).then(function (blob) {\n        resolve(blob);\n      });\n    });\n  };\n\n  ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n    var _this = this;\n\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      var zipData = [];\n      var dirLength = 0;\n\n      for (var i = 0; i < zipArchive.files.length; i++) {\n        var compressedObject = _this.getCompressedData(_this.files[i]);\n\n        compressedObject.then(function (data) {\n          dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n\n          if (zipData.length === zipArchive.files.length) {\n            var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n            resolve(blob);\n          }\n        });\n      }\n    });\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  ZipArchive.prototype.destroy = function () {\n    if (this.files !== undefined && this.files.length > 0) {\n      for (var i = 0; i < this.files.length; i++) {\n        var file = this.files[i];\n\n        if (file instanceof ZipArchiveItem) {\n          file.destroy();\n        }\n\n        file = undefined;\n      }\n\n      this.files = [];\n    }\n\n    this.files = undefined;\n    this.level = undefined;\n  };\n\n  ZipArchive.prototype.getCompressedData = function (item) {\n    var zipArchive = this;\n    var promise = new Promise(function (resolve, reject) {\n      if (item instanceof ZipArchiveItem) {\n        var reader_1 = new FileReader();\n\n        reader_1.onload = function () {\n          var input = new Uint8Array(reader_1.result);\n          var data = {\n            fileName: item.name,\n            crc32Value: 0,\n            compressedData: [],\n            compressedSize: undefined,\n            uncompressedDataSize: input.length,\n            compressionType: undefined,\n            isDirectory: false\n          };\n\n          if (zipArchive.level === 'Normal') {\n            zipArchive.compressData(input, data, CRC32TABLE);\n            var length_1 = 0;\n\n            for (var i = 0; i < data.compressedData.length; i++) {\n              length_1 += data.compressedData[i].length;\n            }\n\n            data.compressedSize = length_1;\n            data.compressionType = '\\x08\\x00'; //Deflated = 8\n          } else {\n            data.compressedSize = input.length;\n            data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n            data.compressionType = '\\x00\\x00'; // Stored = 0\n\n            data.compressedData.push(input);\n          }\n\n          resolve(data);\n        };\n\n        reader_1.readAsArrayBuffer(item.data);\n      } else {\n        var data = {\n          fileName: item,\n          crc32Value: 0,\n          compressedData: '',\n          compressedSize: 0,\n          uncompressedDataSize: 0,\n          compressionType: '\\x00\\x00',\n          isDirectory: true\n        };\n        resolve(data);\n      }\n    });\n    return promise;\n  };\n\n  ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n    var compressor = new CompressedStreamWriter(true);\n    var currentIndex = 0;\n    var nextIndex = 0;\n\n    do {\n      if (currentIndex >= input.length) {\n        compressor.close();\n        break;\n      }\n\n      nextIndex = Math.min(input.length, currentIndex + 16384);\n      var subArray = input.subarray(currentIndex, nextIndex);\n      data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n      compressor.write(subArray, 0, nextIndex - currentIndex);\n      currentIndex = nextIndex;\n    } while (currentIndex <= input.length);\n\n    data.compressedData = compressor.compressedData;\n    compressor.destroy();\n  };\n\n  ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n    var extFileAttr = 0;\n    var date = new Date();\n\n    if (isDirectory) {\n      extFileAttr = extFileAttr | 0x00010; // directory flag\n    }\n\n    extFileAttr = extFileAttr | 0 & 0x3F;\n    var header = this.writeHeader(data, date);\n    var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n    var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n    zipParts.push({\n      localHeader: localHeader,\n      centralDir: centralDir,\n      compressedData: data\n    });\n    return dirLength + localHeader.length + data.compressedSize;\n  };\n\n  ZipArchive.prototype.writeHeader = function (data, date) {\n    var zipHeader = '';\n    zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n\n    zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n\n    zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n\n    zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n\n    zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n\n    zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n\n    zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n\n    zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n\n    zipHeader += this.getBytes(0, 2); // extra field length\n\n    return zipHeader;\n  };\n\n  ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n    var cenDirLen = 0;\n    var buffer = [];\n\n    for (var i = 0; i < zipData.length; i++) {\n      var item = zipData[i];\n      cenDirLen += item.centralDir.length;\n      buffer.push(this.getArrayBuffer(item.localHeader));\n\n      while (item.compressedData.compressedData.length) {\n        buffer.push(item.compressedData.compressedData.shift().buffer);\n      }\n    }\n\n    for (var i = 0; i < zipData.length; i++) {\n      buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n    }\n\n    buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n    var blob = new Blob(buffer, {\n      type: 'application/zip'\n    });\n\n    if (!skipFileSave) {\n      Save.save(fileName, blob);\n    }\n\n    return blob;\n  };\n\n  ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n    var directoryHeader = 'PK\\x01\\x02' + this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n    this.getBytes(0, 2) + // comment length\n    '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n    this.getBytes(externalFileAttribute, 4) + // external file attributes\n    this.getBytes(offset, 4) + // local fileHeader relative offset\n    data.fileName;\n    return directoryHeader;\n  };\n\n  ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n    var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);\n    return dirEnd;\n  };\n\n  ZipArchive.prototype.getArrayBuffer = function (input) {\n    var a = new Uint8Array(input.length);\n\n    for (var j = 0; j < input.length; ++j) {\n      a[j] = input.charCodeAt(j) & 0xFF;\n    }\n\n    return a.buffer;\n  };\n\n  ZipArchive.prototype.getBytes = function (value, offset) {\n    var bytes = '';\n\n    for (var i = 0; i < offset; i++) {\n      bytes += String.fromCharCode(value & 0xff);\n      value = value >>> 8;\n    }\n\n    return bytes;\n  };\n\n  ZipArchive.prototype.getModifiedTime = function (date) {\n    var modTime = date.getHours();\n    modTime = modTime << 6;\n    modTime = modTime | date.getMinutes();\n    modTime = modTime << 5;\n    return modTime = modTime | date.getSeconds() / 2;\n  };\n\n  ZipArchive.prototype.getModifiedDate = function (date) {\n    var modiDate = date.getFullYear() - 1980;\n    modiDate = modiDate << 4;\n    modiDate = modiDate | date.getMonth() + 1;\n    modiDate = modiDate << 5;\n    return modiDate = modiDate | date.getDate();\n  };\n\n  ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n    crc32Value ^= -1;\n\n    for (var i = 0; i < input.length; i++) {\n      crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n    }\n\n    return crc32Value ^ -1;\n  };\n  /**\n   * construct cyclic redundancy code table\n   * @private\n   */\n\n\n  ZipArchive.initCrc32Table = function () {\n    var i;\n\n    for (var j = 0; j < 256; j++) {\n      i = j;\n\n      for (var k = 0; k < 8; k++) {\n        i = i & 1 ? 0xEDB88320 ^ i >>> 1 : i >>> 1;\n      }\n\n      CRC32TABLE[j] = i;\n    }\n  };\n\n  return ZipArchive;\n}();\n\nexport { ZipArchive };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\n\nvar ZipArchiveItem =\n/** @class */\nfunction () {\n  /**\n   * constructor for creating {ZipArchiveItem} instance\n   * @param {Blob|ArrayBuffer} data file data\n   * @param {itemName} itemName absolute file path\n   */\n  function ZipArchiveItem(data, itemName) {\n    if (data === null || data === undefined) {\n      throw new Error('ArgumentException: data cannot be null or undefined');\n    }\n\n    if (itemName === null || itemName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (itemName.length === 0) {\n      throw new Error('string cannot be empty');\n    }\n\n    this.data = data;\n    this.name = itemName;\n  }\n\n  Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n    /**\n     * Get the name of archive item\n     * @returns string\n     */\n    get: function () {\n      return this.fileName;\n    },\n\n    /**\n     * Set the name of archive item\n     * @param  {string} value\n     */\n    set: function (value) {\n      this.fileName = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n  ZipArchiveItem.prototype.destroy = function () {\n    this.fileName = undefined;\n    this.data = undefined;\n  };\n\n  return ZipArchiveItem;\n}();\n\nexport { ZipArchiveItem };","map":{"version":3,"sources":["/Users/ewong/Development/Whiteboard/node_modules/@syncfusion/ej2-compression/src/zip-archive.js"],"names":["CompressedStreamWriter","Save","CRC32TABLE","ZipArchive","length","initCrc32Table","files","level","isMicrosoftBrowser","navigator","msSaveBlob","Object","defineProperty","prototype","get","set","enumerable","configurable","undefined","addItem","item","Error","i","file","ZipArchiveItem","name","push","addDirectory","directoryName","slice","indexOf","getItem","index","contains","save","fileName","zipArchive","promise","Promise","resolve","reject","saveInternal","then","saveAsBlob","blob","skipFileSave","_this","zipData","dirLength","compressedObject","getCompressedData","data","constructZippedObject","isDirectory","writeZippedContent","destroy","reader_1","FileReader","onload","input","Uint8Array","result","crc32Value","compressedData","compressedSize","uncompressedDataSize","compressionType","compressData","length_1","calculateCrc32Value","readAsArrayBuffer","crc32Table","compressor","currentIndex","nextIndex","close","Math","min","subArray","subarray","write","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getBytes","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","buffer","getArrayBuffer","shift","writeFooter","Blob","type","offset","externalFileAttribute","directoryHeader","centralLength","localLength","dirEnd","a","j","charCodeAt","value","bytes","String","fromCharCode","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","k","itemName"],"mappings":"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","sourcesContent":["import { CompressedStreamWriter } from './compression-writer';\nimport { Save } from '@syncfusion/ej2-file-utils';\nvar CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @class */ (function () {\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    function ZipArchive() {\n        if (CRC32TABLE.length === 0) {\n            ZipArchive.initCrc32Table();\n        }\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n        /**\n         * gets compression level\n         */\n        get: function () {\n            return this.level;\n        },\n        /**\n         * sets compression level\n         */\n        set: function (level) {\n            this.level = level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"length\", {\n        /**\n         * gets items count\n         */\n        get: function () {\n            if (this.files === undefined) {\n                return 0;\n            }\n            return this.files.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    ZipArchive.prototype.addItem = function (item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (var i = 0; i < this.files.length; i++) {\n            var file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    };\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    ZipArchive.prototype.addDirectory = function (directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    };\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    ZipArchive.prototype.getItem = function (index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    };\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    ZipArchive.prototype.contains = function (item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    };\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    ZipArchive.prototype.save = function (fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal(fileName, false).then(function () {\n                resolve(zipArchive);\n            });\n        });\n    };\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    ZipArchive.prototype.saveAsBlob = function () {\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal('', true).then(function (blob) {\n                resolve(blob);\n            });\n        });\n    };\n    ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n        var _this = this;\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            var zipData = [];\n            var dirLength = 0;\n            for (var i = 0; i < zipArchive.files.length; i++) {\n                var compressedObject = _this.getCompressedData(_this.files[i]);\n                compressedObject.then(function (data) {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchive.prototype.destroy = function () {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (var i = 0; i < this.files.length; i++) {\n                var file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    };\n    ZipArchive.prototype.getCompressedData = function (item) {\n        var zipArchive = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (item instanceof ZipArchiveItem) {\n                var reader_1 = new FileReader();\n                reader_1.onload = function () {\n                    var input = new Uint8Array(reader_1.result);\n                    var data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, CRC32TABLE);\n                        var length_1 = 0;\n                        for (var i = 0; i < data.compressedData.length; i++) {\n                            length_1 += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length_1;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader_1.readAsArrayBuffer(item.data);\n            }\n            else {\n                var data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    };\n    ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n        var compressor = new CompressedStreamWriter(true);\n        var currentIndex = 0;\n        var nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            var subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    };\n    ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n        var extFileAttr = 0;\n        var date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        var header = this.writeHeader(data, date);\n        var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    };\n    ZipArchive.prototype.writeHeader = function (data, date) {\n        var zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    };\n    ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n        var cenDirLen = 0;\n        var buffer = [];\n        for (var i = 0; i < zipData.length; i++) {\n            var item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (var i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        var blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    };\n    ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n        var directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    };\n    ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n        var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    };\n    ZipArchive.prototype.getArrayBuffer = function (input) {\n        var a = new Uint8Array(input.length);\n        for (var j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    };\n    ZipArchive.prototype.getBytes = function (value, offset) {\n        var bytes = '';\n        for (var i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    };\n    ZipArchive.prototype.getModifiedTime = function (date) {\n        var modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    };\n    ZipArchive.prototype.getModifiedDate = function (date) {\n        var modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    };\n    ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (var i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    };\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n    ZipArchive.initCrc32Table = function () {\n        var i;\n        for (var j = 0; j < 256; j++) {\n            i = j;\n            for (var k = 0; k < 8; k++) {\n                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n            }\n            CRC32TABLE[j] = i;\n        }\n    };\n    return ZipArchive;\n}());\nexport { ZipArchive };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @class */ (function () {\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    function ZipArchiveItem(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n        /**\n         * Get the name of archive item\n         * @returns string\n         */\n        get: function () {\n            return this.fileName;\n        },\n        /**\n         * Set the name of archive item\n         * @param  {string} value\n         */\n        set: function (value) {\n            this.fileName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchiveItem.prototype.destroy = function () {\n        this.fileName = undefined;\n        this.data = undefined;\n    };\n    return ZipArchiveItem;\n}());\nexport { ZipArchiveItem };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\n\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\n\nvar CompressedStreamWriter =\n/** @class */\nfunction () {\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  function CompressedStreamWriter(noWrap) {\n    this.pendingBuffer = new Uint8Array(1 << 16);\n    this.pendingBufLength = 0;\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.currentHash = 0;\n    this.matchStart = 0;\n    this.matchLength = 0;\n    this.matchPrevAvail = false;\n    this.blockStart = 0;\n    this.stringStart = 0;\n    this.lookAhead = 0;\n    this.totalBytesIn = 0;\n    this.inputOffset = 0;\n    this.inputEnd = 0;\n    this.windowSize = 1 << 15;\n    this.windowMask = this.windowSize - 1;\n    this.hashSize = 1 << 15;\n    this.hashMask = this.hashSize - 1;\n    this.hashShift = Math.floor((15 + 3 - 1) / 3);\n    this.maxDist = this.windowSize - 262;\n    this.checkSum = 1;\n    this.noWrap = false;\n\n    if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n      CompressedStreamWriter.initHuffmanTree();\n      CompressedStreamWriter.isHuffmanTreeInitiated = true;\n    }\n\n    this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n    this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n    this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n    this.arrDistances = new Uint16Array(1 << 14);\n    this.arrLiterals = new Uint8Array(1 << 14);\n    this.stream = [];\n    this.dataWindow = new Uint8Array(2 * this.windowSize);\n    this.hashHead = new Int16Array(this.hashSize);\n    this.hashPrevious = new Int16Array(this.windowSize);\n    this.blockStart = this.stringStart = 1;\n    this.noWrap = noWrap;\n\n    if (!noWrap) {\n      this.writeZLibHeader();\n    }\n  }\n\n  Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n    /**\n     * get compressed data\n     */\n    get: function () {\n      return this.stream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n    get: function () {\n      var compressedString = '';\n\n      if (this.stream !== undefined) {\n        for (var i = 0; i < this.stream.length; i++) {\n          compressedString += String.fromCharCode.apply(null, this.stream[i]);\n        }\n      }\n\n      return compressedString;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Compresses data and writes it to the stream.\n   * @param {Uint8Array} data - data to compress\n   * @param {number} offset - offset in data\n   * @param {number} length - length of the data\n   * @returns {void}\n   */\n\n  CompressedStreamWriter.prototype.write = function (data, offset, length) {\n    if (data === undefined || data === null) {\n      throw new Error('ArgumentException: data cannot null or undefined');\n    }\n\n    var end = offset + length;\n\n    if (0 > offset || offset > end || end > data.length) {\n      throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n    }\n\n    if (typeof data === 'string') {\n      var encode = new Encoding(false);\n      encode.type = 'Utf8';\n      data = new Uint8Array(encode.getBytes(data, 0, data.length));\n      end = offset + data.length;\n    }\n\n    this.inputBuffer = data;\n    this.inputOffset = offset;\n    this.inputEnd = end;\n\n    if (!this.noWrap) {\n      this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n    }\n\n    while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n      this.pendingBufferFlush();\n      this.compressData(false);\n    }\n  };\n  /**\n   * write ZLib header to the compressed data\n   * @return {void}\n   */\n\n\n  CompressedStreamWriter.prototype.writeZLibHeader = function () {\n    /* Initialize header.*/\n    var headerDate = 8 + (7 << 4) << 8;\n    /* Save compression level.*/\n\n    headerDate |= (5 >> 2 & 3) << 6;\n    /* Align header.*/\n\n    headerDate += 31 - headerDate % 31;\n    /* Write header to stream.*/\n\n    this.pendingBufferWriteShortBytes(headerDate);\n  };\n  /**\n   *  Write Most Significant Bytes in to stream\n   * @param {number} s - check sum value\n   */\n\n\n  CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n    this.pendingBuffer[this.pendingBufLength++] = s;\n  };\n\n  CompressedStreamWriter.prototype.compressData = function (finish) {\n    var success;\n\n    do {\n      this.fillWindow();\n      var canFlush = finish && this.inputEnd === this.inputOffset;\n      success = this.compressSlow(canFlush, finish);\n    } while (this.pendingBufLength === 0 && success);\n\n    return success;\n  };\n\n  CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n    if (this.lookAhead < 262 && !flush) {\n      return false;\n    }\n\n    while (this.lookAhead >= 262 || flush) {\n      if (this.lookAhead === 0) {\n        return this.lookAheadCompleted(finish);\n      }\n\n      if (this.stringStart >= 2 * this.windowSize - 262) {\n        this.slideWindow();\n      }\n\n      var prevMatch = this.matchStart;\n      var prevLen = this.matchLength;\n\n      if (this.lookAhead >= 3) {\n        this.discardMatch();\n      }\n\n      if (prevLen >= 3 && this.matchLength <= prevLen) {\n        prevLen = this.matchPreviousBest(prevMatch, prevLen);\n      } else {\n        this.matchPreviousAvailable();\n      }\n\n      if (this.bufferPosition >= 1 << 14) {\n        return this.huffmanIsFull(finish);\n      }\n    }\n\n    return true;\n  };\n\n  CompressedStreamWriter.prototype.discardMatch = function () {\n    var hashHead = this.insertString();\n\n    if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n      if (this.matchLength <= 5 && this.matchLength === 3 && this.stringStart - this.matchStart > 4096) {\n        this.matchLength = 3 - 1;\n      }\n    }\n  };\n\n  CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = true;\n    this.stringStart++;\n    this.lookAhead--;\n  };\n\n  CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n    this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n    prevLen -= 2;\n\n    do {\n      this.stringStart++;\n      this.lookAhead--;\n\n      if (this.lookAhead >= 3) {\n        this.insertString();\n      }\n    } while (--prevLen > 0);\n\n    this.stringStart++;\n    this.lookAhead--;\n    this.matchPrevAvail = false;\n    this.matchLength = 3 - 1;\n    return prevLen;\n  };\n\n  CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = false;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n    this.blockStart = this.stringStart;\n    return false;\n  };\n\n  CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n    var len = this.stringStart - this.blockStart;\n\n    if (this.matchPrevAvail) {\n      len--;\n    }\n\n    var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n    this.blockStart += len;\n    return !lastBlock;\n  };\n\n  CompressedStreamWriter.prototype.fillWindow = function () {\n    if (this.stringStart >= this.windowSize + this.maxDist) {\n      this.slideWindow();\n    }\n\n    while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n      var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n\n      if (more > this.inputEnd - this.inputOffset) {\n        more = this.inputEnd - this.inputOffset;\n      }\n\n      this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n      this.inputOffset += more;\n      this.totalBytesIn += more;\n      this.lookAhead += more;\n    }\n\n    if (this.lookAhead >= 3) {\n      this.updateHash();\n    }\n  };\n\n  CompressedStreamWriter.prototype.slideWindow = function () {\n    this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n    this.matchStart -= this.windowSize;\n    this.stringStart -= this.windowSize;\n    this.blockStart -= this.windowSize;\n\n    for (var i = 0; i < this.hashSize; ++i) {\n      var m = this.hashHead[i] & 0xffff;\n      this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n\n    for (var i = 0; i < this.windowSize; i++) {\n      var m = this.hashPrevious[i] & 0xffff;\n      this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n  };\n\n  CompressedStreamWriter.prototype.insertString = function () {\n    var match;\n    var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n    this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n    this.hashHead[hash] = this.stringStart;\n    this.currentHash = hash;\n    return match & 0xffff;\n  };\n\n  CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n    var chainLen = 4096;\n    var niceLen = 258;\n    var scan = this.stringStart;\n    var match;\n    var bestEnd = this.stringStart + this.matchLength;\n    var bestLength = Math.max(this.matchLength, 3 - 1);\n    var limit = Math.max(this.stringStart - this.maxDist, 0);\n    var stringEnd = this.stringStart + 258 - 1;\n    var scanEnd1 = this.dataWindow[bestEnd - 1];\n    var scanEnd = this.dataWindow[bestEnd];\n    var data = this.dataWindow;\n\n    if (bestLength >= 32) {\n      chainLen >>= 2;\n    }\n\n    if (niceLen > this.lookAhead) {\n      niceLen = this.lookAhead;\n    }\n\n    do {\n      if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {\n        continue;\n      }\n\n      match = curMatch + 2;\n      scan += 2;\n      /* tslint:disable */\n\n      while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n        /* tslint:disable */\n      }\n\n      if (scan > bestEnd) {\n        this.matchStart = curMatch;\n        bestEnd = scan;\n        bestLength = scan - this.stringStart;\n\n        if (bestLength >= niceLen) {\n          break;\n        }\n\n        scanEnd1 = data[bestEnd - 1];\n        scanEnd = data[bestEnd];\n      }\n\n      scan = this.stringStart;\n    } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 0xffff) > limit && --chainLen !== 0);\n\n    this.matchLength = Math.min(bestLength, this.lookAhead);\n    return this.matchLength >= 3;\n  };\n\n  CompressedStreamWriter.prototype.updateHash = function () {\n    this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];\n  };\n\n  CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n    this.arrDistances[this.bufferPosition] = 0;\n    this.arrLiterals[this.bufferPosition++] = literal;\n    this.treeLiteral.codeFrequencies[literal]++;\n    return this.bufferPosition >= 1 << 14;\n  };\n\n  CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n    this.arrDistances[this.bufferPosition] = dist;\n    this.arrLiterals[this.bufferPosition++] = len - 3;\n    var lc = this.huffmanLengthCode(len - 3);\n    this.treeLiteral.codeFrequencies[lc]++;\n\n    if (lc >= 265 && lc < 285) {\n      this.extraBits += Math.floor((lc - 261) / 4);\n    }\n\n    var dc = this.huffmanDistanceCode(dist - 1);\n    this.treeDistances.codeFrequencies[dc]++;\n\n    if (dc >= 4) {\n      this.extraBits += Math.floor(dc / 2 - 1);\n    }\n\n    return this.bufferPosition >= 1 << 14;\n  };\n\n  CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.treeLiteral.codeFrequencies[256]++;\n    this.treeLiteral.buildTree();\n    this.treeDistances.buildTree();\n    this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n    this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n    this.treeCodeLengths.buildTree();\n    var blTreeCodes = 4;\n\n    for (var i = 18; i > blTreeCodes; i--) {\n      if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n        blTreeCodes = i + 1;\n      }\n    }\n\n    var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n    var static_len = this.extraBits;\n\n    for (var i = 0; i < 286; i++) {\n      static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n    }\n\n    for (var i = 0; i < 30; i++) {\n      static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n    }\n\n    if (opt_len >= static_len) {\n      // Force static trees.\n      opt_len = static_len;\n    }\n\n    if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n      this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n    } else if (opt_len == static_len) {\n      // Encode with static tree.\n      this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n      this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n      this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    } else {\n      this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n      this.huffmanSendAllTrees(blTreeCodes);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    }\n  };\n\n  CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n    this.pendingBufferAlignToByte();\n    this.pendingBufferWriteShort(storedLength);\n    this.pendingBufferWriteShort(~storedLength);\n    this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n    this.huffmanReset();\n  };\n\n  CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n    if (len === 255) {\n      return 285;\n    }\n\n    var code = 257;\n\n    while (len >= 8) {\n      code += 4;\n      len >>= 1;\n    }\n\n    return code + len;\n  };\n\n  CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n    var code = 0;\n\n    while (distance >= 4) {\n      code += 2;\n      distance >>= 1;\n    }\n\n    return code + distance;\n  };\n\n  CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n    this.treeCodeLengths.buildCodes();\n    this.treeLiteral.buildCodes();\n    this.treeDistances.buildCodes();\n    this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n    this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n    this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n\n    for (var rank = 0; rank < blTreeCodes; rank++) {\n      this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n    }\n\n    this.treeLiteral.writeTree(this.treeCodeLengths);\n    this.treeDistances.writeTree(this.treeCodeLengths);\n  };\n\n  CompressedStreamWriter.prototype.huffmanReset = function () {\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.treeLiteral.reset();\n    this.treeDistances.reset();\n    this.treeCodeLengths.reset();\n  };\n\n  CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n    for (var i = 0; i < this.bufferPosition; i++) {\n      var literalLen = this.arrLiterals[i] & 255;\n      var dist = this.arrDistances[i];\n\n      if (dist-- !== 0) {\n        var lc = this.huffmanLengthCode(literalLen);\n        this.treeLiteral.writeCodeToStream(lc);\n        var bits = Math.floor((lc - 261) / 4);\n\n        if (bits > 0 && bits <= 5) {\n          this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);\n        }\n\n        var dc = this.huffmanDistanceCode(dist);\n        this.treeDistances.writeCodeToStream(dc);\n        bits = Math.floor(dc / 2 - 1);\n\n        if (bits > 0) {\n          this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);\n        }\n      } else {\n        this.treeLiteral.writeCodeToStream(literalLen);\n      }\n    }\n\n    this.treeLiteral.writeCodeToStream(256);\n  };\n  /**\n   * write bits in to internal buffer\n   * @param {number} b - source of bits\n   * @param {number} count - count of bits to write\n   */\n\n\n  CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n    var uint = new Uint32Array(1);\n    uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;\n    this.pendingBufCache = uint[0];\n    this.pendingBufBitsInCache += count;\n    this.pendingBufferFlushBits();\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n    this.pendingBufferFlushBits();\n\n    if (this.pendingBufLength > 0) {\n      var array = new Uint8Array(this.pendingBufLength);\n      array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n      this.stream.push(array);\n    }\n\n    this.pendingBufLength = 0;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n    var result = 0;\n\n    while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n      this.pendingBufCache >>= 8;\n      this.pendingBufBitsInCache -= 8;\n      result++;\n    }\n\n    return result;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n    var array = data.subarray(offset, offset + length);\n    this.pendingBuffer.set(array, this.pendingBufLength);\n    this.pendingBufLength += length;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s;\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n    if (this.pendingBufBitsInCache > 0) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n    }\n\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n  };\n  /**\n   * Huffman Tree literal calculation\n   * @private\n   */\n\n\n  CompressedStreamWriter.initHuffmanTree = function () {\n    var i = 0;\n\n    while (i < 144) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x030 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    while (i < 256) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x190 - 144 + i << 7);\n      ARR_LITERAL_LENGTHS[i++] = 9;\n    }\n\n    while (i < 280) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x000 - 256 + i << 9);\n      ARR_LITERAL_LENGTHS[i++] = 7;\n    }\n\n    while (i < 286) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x0c0 - 280 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    for (i = 0; i < 30; i++) {\n      ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n      ARR_DISTANCE_LENGTHS[i] = 5;\n    }\n  };\n  /**\n   * close the stream and write all pending buffer in to stream\n   * @returns {void}\n   */\n\n\n  CompressedStreamWriter.prototype.close = function () {\n    do {\n      this.pendingBufferFlush(true);\n\n      if (!this.compressData(true)) {\n        this.pendingBufferFlush(true);\n        this.pendingBufferAlignToByte();\n\n        if (!this.noWrap) {\n          this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n          this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n        }\n\n        this.pendingBufferFlush(true);\n      }\n    } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  CompressedStreamWriter.prototype.destroy = function () {\n    this.stream = [];\n    this.stream = undefined;\n    this.pendingBuffer = undefined;\n    this.treeLiteral = undefined;\n    this.treeDistances = undefined;\n    this.treeCodeLengths = undefined;\n    this.arrLiterals = undefined;\n    this.arrDistances = undefined;\n    this.hashHead = undefined;\n    this.hashPrevious = undefined;\n    this.dataWindow = undefined;\n    this.inputBuffer = undefined;\n    this.pendingBufLength = undefined;\n    this.pendingBufCache = undefined;\n    this.pendingBufBitsInCache = undefined;\n    this.bufferPosition = undefined;\n    this.extraBits = undefined;\n    this.currentHash = undefined;\n    this.matchStart = undefined;\n    this.matchLength = undefined;\n    this.matchPrevAvail = undefined;\n    this.blockStart = undefined;\n    this.stringStart = undefined;\n    this.lookAhead = undefined;\n    this.totalBytesIn = undefined;\n    this.inputOffset = undefined;\n    this.inputEnd = undefined;\n    this.windowSize = undefined;\n    this.windowMask = undefined;\n    this.hashSize = undefined;\n    this.hashMask = undefined;\n    this.hashShift = undefined;\n    this.maxDist = undefined;\n    this.checkSum = undefined;\n    this.noWrap = undefined;\n  };\n\n  CompressedStreamWriter.isHuffmanTreeInitiated = false;\n  return CompressedStreamWriter;\n}();\n\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\n\nvar CompressorHuffmanTree =\n/** @class */\nfunction () {\n  /**\n   * Create new Huffman Tree\n   * @param {CompressedStreamWriter} writer instance\n   * @param {number} elementCount - element count\n   * @param {number} minCodes - minimum count\n   * @param {number} maxLength - maximum count\n   */\n  function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n    this.writer = writer;\n    this.codeMinCount = minCodes;\n    this.maxLength = maxLength;\n    this.codeFrequency = new Uint16Array(elementCount);\n    this.lengthCount = new Int32Array(maxLength);\n  }\n\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n    get: function () {\n      return this.codeCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n    get: function () {\n      return this.codeLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n    get: function () {\n      return this.codeFrequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n    var temp = new Int16Array(codes.length);\n    temp.set(codes, 0);\n    this.codes = temp;\n    var lengthTemp = new Uint8Array(lengths.length);\n    lengthTemp.set(lengths, 0);\n    this.codeLength = lengthTemp;\n  };\n  /**\n   * reset all code data in tree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.reset = function () {\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      this.codeFrequency[i] = 0;\n    }\n\n    this.codes = undefined;\n    this.codeLength = undefined;\n  };\n  /**\n   * write code to the compressor output stream\n   * @param {number} code - code to be written\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n    this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n  };\n  /**\n   * calculate code from their frequencies\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.buildCodes = function () {\n    var nextCode = new Int32Array(this.maxLength);\n    this.codes = new Int16Array(this.codeCount);\n    var code = 0;\n\n    for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n      nextCode[bitsCount] = code;\n      code += this.lengthCount[bitsCount] << 15 - bitsCount;\n    }\n\n    for (var i = 0; i < this.codeCount; i++) {\n      var bits = this.codeLength[i];\n\n      if (bits > 0) {\n        this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n        nextCode[bits - 1] += 1 << 16 - bits;\n      }\n    }\n  };\n\n  CompressorHuffmanTree.bitReverse = function (value) {\n    return CompressorHuffmanTree.reverseBits[value & 15] << 12 | CompressorHuffmanTree.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree.reverseBits[value >> 12];\n  };\n  /**\n   * calculate length of compressed data\n   * @returns {number}\n   */\n\n\n  CompressorHuffmanTree.prototype.getEncodedLength = function () {\n    var len = 0;\n\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      len += this.codeFrequency[i] * this.codeLength[i];\n    }\n\n    return len;\n  };\n  /**\n   * calculate code frequencies\n   * @param {CompressorHuffmanTree} blTree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n    var maxCount;\n    var minCount;\n    var count;\n    var curLen = -1;\n    var i = 0;\n\n    while (i < this.codeCount) {\n      count = 1;\n      var nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxCount = 138;\n        minCount = 3;\n      } else {\n        maxCount = 6;\n        minCount = 3;\n\n        if (curLen !== nextLen) {\n          blTree.codeFrequency[nextLen]++;\n          count = 0;\n        }\n      }\n\n      curLen = nextLen;\n      i++;\n\n      while (i < this.codeCount && curLen === this.codeLength[i]) {\n        i++;\n\n        if (++count >= maxCount) {\n          break;\n        }\n      }\n\n      if (count < minCount) {\n        blTree.codeFrequency[curLen] += count;\n      } else if (curLen !== 0) {\n        blTree.codeFrequency[16]++;\n      } else if (count <= 10) {\n        blTree.codeFrequency[17]++;\n      } else {\n        blTree.codeFrequency[18]++;\n      }\n    }\n  };\n  /**\n   * @param {CompressorHuffmanTree} blTree - write tree to output stream\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n    var maxRepeatCount;\n    var minRepeatCount;\n    var currentRepeatCount;\n    var currentCodeLength = -1;\n    var i = 0;\n\n    while (i < this.codeCount) {\n      currentRepeatCount = 1;\n      var nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxRepeatCount = 138;\n        minRepeatCount = 3;\n      } else {\n        maxRepeatCount = 6;\n        minRepeatCount = 3;\n\n        if (currentCodeLength !== nextLen) {\n          blTree.writeCodeToStream(nextLen);\n          currentRepeatCount = 0;\n        }\n      }\n\n      currentCodeLength = nextLen;\n      i++;\n\n      while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n        i++;\n\n        if (++currentRepeatCount >= maxRepeatCount) {\n          break;\n        }\n      }\n\n      if (currentRepeatCount < minRepeatCount) {\n        while (currentRepeatCount-- > 0) {\n          blTree.writeCodeToStream(currentCodeLength);\n        }\n      } else if (currentCodeLength !== 0) {\n        blTree.writeCodeToStream(16);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n      } else if (currentRepeatCount <= 10) {\n        blTree.writeCodeToStream(17);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n      } else {\n        blTree.writeCodeToStream(18);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n      }\n    }\n  };\n  /**\n   * Build huffman tree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.buildTree = function () {\n    var codesCount = this.codeFrequency.length;\n    var arrTree = new Int32Array(codesCount);\n    var treeLength = 0;\n    var maxCount = 0;\n\n    for (var n = 0; n < codesCount; n++) {\n      var freq = this.codeFrequency[n];\n\n      if (freq !== 0) {\n        var pos = treeLength++;\n        var pPos = 0;\n\n        while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n          arrTree[pos] = arrTree[pPos];\n          pos = pPos;\n        }\n\n        arrTree[pos] = n;\n        maxCount = n;\n      }\n    }\n\n    while (treeLength < 2) {\n      arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;\n    }\n\n    this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n    var leafsCount = treeLength;\n    var nodesCount = leafsCount;\n    var child = new Int32Array(4 * treeLength - 2);\n    var values = new Int32Array(2 * treeLength - 1);\n\n    for (var i = 0; i < treeLength; i++) {\n      var node = arrTree[i];\n      var iIndex = 2 * i;\n      child[iIndex] = node;\n      child[iIndex + 1] = -1;\n      values[i] = this.codeFrequency[node] << 8;\n      arrTree[i] = i;\n    }\n\n    this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n    this.buildLength(child);\n  };\n\n  CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n    do {\n      var first = arrTree[0];\n      var last = arrTree[--treeLength];\n      var lastVal = values[last];\n      var pPos = 0;\n      var path = 1;\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n      var second = arrTree[0];\n      last = nodesCount++;\n      child[2 * last] = first;\n      child[2 * last + 1] = second;\n      var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n      values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n      pPos = 0;\n      path = 1;\n      /* tslint:disable */\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n      /* tslint:disable */\n\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n    } while (treeLength > 1);\n  };\n\n  CompressorHuffmanTree.prototype.buildLength = function (child) {\n    this.codeLength = new Uint8Array(this.codeFrequency.length);\n    var numNodes = Math.floor(child.length / 2);\n    var numLeafs = Math.floor((numNodes + 1) / 2);\n    var overflow = 0;\n\n    for (var i = 0; i < this.maxLength; i++) {\n      this.lengthCount[i] = 0;\n    }\n\n    overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n\n    if (overflow === 0) {\n      return;\n    }\n\n    var iIncreasableLength = this.maxLength - 1;\n\n    do {\n      while (this.lengthCount[--iIncreasableLength] === 0) {\n        /* tslint:disable */\n      }\n\n      do {\n        this.lengthCount[iIncreasableLength]--;\n        this.lengthCount[++iIncreasableLength]++;\n        overflow -= 1 << this.maxLength - 1 - iIncreasableLength;\n      } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n    } while (overflow > 0);\n\n    this.recreateTree(child, overflow, numLeafs);\n  };\n\n  CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n    this.lengthCount[this.maxLength - 1] += overflow;\n    this.lengthCount[this.maxLength - 2] -= overflow;\n    var nodePtr = 2 * numLeafs;\n\n    for (var bits = this.maxLength; bits !== 0; bits--) {\n      var n = this.lengthCount[bits - 1];\n\n      while (n > 0) {\n        var childPtr = 2 * child[nodePtr++];\n\n        if (child[childPtr + 1] === -1) {\n          this.codeLength[child[childPtr]] = bits;\n          n--;\n        }\n      }\n    }\n  };\n\n  CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n    var lengths = new Int32Array(numNodes);\n    lengths[numNodes - 1] = 0;\n\n    for (var i = numNodes - 1; i >= 0; i--) {\n      var childIndex = 2 * i + 1;\n\n      if (child[childIndex] !== -1) {\n        var bitLength = lengths[i] + 1;\n\n        if (bitLength > this.maxLength) {\n          bitLength = this.maxLength;\n          overflow++;\n        }\n\n        lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n      } else {\n        var bitLength = lengths[i];\n        this.lengthCount[bitLength - 1]++;\n        this.codeLength[child[childIndex - 1]] = lengths[i];\n      }\n    }\n\n    return overflow;\n  };\n\n  CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n  CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  return CompressorHuffmanTree;\n}();\n\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\n\nvar ChecksumCalculator =\n/** @class */\nfunction () {\n  function ChecksumCalculator() {}\n  /**\n   * Updates checksum by calculating checksum of the\n   * given buffer and adding it to current value.\n   * @param {number} checksum - current checksum.\n   * @param {Uint8Array} buffer - data byte array.\n   * @param {number} offset - offset in the buffer.\n   * @param {number} length - length of data to be used from the stream.\n   * @returns {number}\n   */\n\n\n  ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n    var uint = new Uint32Array(1);\n    uint[0] = checksum;\n    var checksum_uint = uint[0];\n    var s1 = uint[0] = checksum_uint & 65535;\n    var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n\n    while (length > 0) {\n      var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n      length -= steps;\n\n      while (--steps >= 0) {\n        s1 = s1 + (uint[0] = buffer[offset++] & 255);\n        s2 = s2 + s1;\n      }\n\n      s1 %= ChecksumCalculator.checksumBase;\n      s2 %= ChecksumCalculator.checksumBase;\n    }\n\n    checksum_uint = s2 << ChecksumCalculator.checkSumBitOffset | s1;\n    return checksum_uint;\n  };\n\n  ChecksumCalculator.checkSumBitOffset = 16;\n  ChecksumCalculator.checksumBase = 65521;\n  ChecksumCalculator.checksumIterationCount = 3800;\n  return ChecksumCalculator;\n}();\n\nexport { ChecksumCalculator };","map":{"version":3,"sources":["D:/developing/projects/whiteboard2.0/node_modules/@syncfusion/ej2-compression/src/compression-writer.js"],"names":["Encoding","ARR_LITERAL_CODES","Int16Array","ARR_LITERAL_LENGTHS","Uint8Array","ARR_DISTANCE_CODES","ARR_DISTANCE_LENGTHS","CompressedStreamWriter","noWrap","pendingBuffer","pendingBufLength","pendingBufCache","pendingBufBitsInCache","bufferPosition","extraBits","currentHash","matchStart","matchLength","matchPrevAvail","blockStart","stringStart","lookAhead","totalBytesIn","inputOffset","inputEnd","windowSize","windowMask","hashSize","hashMask","hashShift","Math","floor","maxDist","checkSum","isHuffmanTreeInitiated","initHuffmanTree","treeLiteral","CompressorHuffmanTree","treeDistances","treeCodeLengths","arrDistances","Uint16Array","arrLiterals","stream","dataWindow","hashHead","hashPrevious","writeZLibHeader","Object","defineProperty","prototype","get","enumerable","configurable","compressedString","undefined","i","length","String","fromCharCode","apply","write","data","offset","Error","end","encode","type","getBytes","inputBuffer","ChecksumCalculator","checksumUpdate","pendingBufferFlush","compressData","headerDate","pendingBufferWriteShortBytes","s","finish","success","fillWindow","canFlush","compressSlow","flush","lookAheadCompleted","slideWindow","prevMatch","prevLen","discardMatch","matchPreviousBest","matchPreviousAvailable","huffmanIsFull","insertString","findLongestMatch","huffmanTallyLit","huffmanTallyDist","huffmanFlushBlock","len","lastBlock","more","set","subarray","updateHash","m","match","hash","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","max","limit","stringEnd","scanEnd1","scanEnd","min","literal","codeFrequencies","dist","lc","huffmanLengthCode","dc","huffmanDistanceCode","stored","storedOffset","storedLength","buildTree","calculateBLFreq","blTreeCodes","codeLengths","huffCodeLengthOrders","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanCompressBlock","huffmanReset","huffmanSendAllTrees","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","literalLen","writeCodeToStream","bits","b","count","uint","Uint32Array","pendingBufferFlushBits","isClose","array","push","result","bitReverse","close","destroy","writer","elementCount","minCodes","maxLength","codeMinCount","codeFrequency","lengthCount","Int32Array","codeCount","codeLength","codes","lengths","temp","lengthTemp","nextCode","bitsCount","value","reverseBits","blTree","maxCount","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentRepeatCount","currentCodeLength","codesCount","arrTree","n","freq","pos","pPos","leafsCount","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","childIndex","bitLength","checksum","buffer","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase"],"mappings":"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","sourcesContent":["import { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @class */ (function () {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    function CompressedStreamWriter(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n            CompressedStreamWriter.initHuffmanTree();\n            CompressedStreamWriter.isHuffmanTreeInitiated = true;\n        }\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n        /**\n         * get compressed data\n         */\n        get: function () {\n            return this.stream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n        get: function () {\n            var compressedString = '';\n            if (this.stream !== undefined) {\n                for (var i = 0; i < this.stream.length; i++) {\n                    compressedString += String.fromCharCode.apply(null, this.stream[i]);\n                }\n            }\n            return compressedString;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.write = function (data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        var end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            var encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    };\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    CompressedStreamWriter.prototype.writeZLibHeader = function () {\n        /* Initialize header.*/\n        var headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    };\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    };\n    CompressedStreamWriter.prototype.compressData = function (finish) {\n        var success;\n        do {\n            this.fillWindow();\n            var canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    };\n    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            var prevMatch = this.matchStart;\n            var prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    };\n    CompressedStreamWriter.prototype.discardMatch = function () {\n        var hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    };\n    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    };\n    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    };\n    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    };\n    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n        var len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    };\n    CompressedStreamWriter.prototype.fillWindow = function () {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    };\n    CompressedStreamWriter.prototype.slideWindow = function () {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (var i = 0; i < this.hashSize; ++i) {\n            var m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (var i = 0; i < this.windowSize; i++) {\n            var m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    };\n    CompressedStreamWriter.prototype.insertString = function () {\n        var match;\n        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    };\n    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n        var chainLen = 4096;\n        var niceLen = 258;\n        var scan = this.stringStart;\n        var match;\n        var bestEnd = this.stringStart + this.matchLength;\n        var bestLength = Math.max(this.matchLength, 3 - 1);\n        var limit = Math.max(this.stringStart - this.maxDist, 0);\n        var stringEnd = this.stringStart + 258 - 1;\n        var scanEnd1 = this.dataWindow[bestEnd - 1];\n        var scanEnd = this.dataWindow[bestEnd];\n        var data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    };\n    CompressedStreamWriter.prototype.updateHash = function () {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    };\n    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        var lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        var dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        var blTreeCodes = 4;\n        for (var i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        var static_len = this.extraBits;\n        for (var i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n        }\n        for (var i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    };\n    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    };\n    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n        if (len === 255) {\n            return 285;\n        }\n        var code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    };\n    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n        var code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    };\n    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (var rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    };\n    CompressedStreamWriter.prototype.huffmanReset = function () {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    };\n    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n        for (var i = 0; i < this.bufferPosition; i++) {\n            var literalLen = this.arrLiterals[i] & 255;\n            var dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                var lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                var bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                var dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    };\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n        var uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            var array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n        var result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n        var array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    };\n    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    };\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n    CompressedStreamWriter.initHuffmanTree = function () {\n        var i = 0;\n        while (i < 144) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        while (i < 256) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n            ARR_LITERAL_LENGTHS[i++] = 9;\n        }\n        while (i < 280) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n            ARR_LITERAL_LENGTHS[i++] = 7;\n        }\n        while (i < 286) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        for (i = 0; i < 30; i++) {\n            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n            ARR_DISTANCE_LENGTHS[i] = 5;\n        }\n    };\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.close = function () {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.destroy = function () {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    };\n    CompressedStreamWriter.isHuffmanTreeInitiated = false;\n    return CompressedStreamWriter;\n}());\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @class */ (function () {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n        get: function () {\n            return this.codeCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n        get: function () {\n            return this.codeLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n        get: function () {\n            return this.codeFrequency;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n        var temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        var lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    };\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.reset = function () {\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    };\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    };\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildCodes = function () {\n        var nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        var code = 0;\n        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (var i = 0; i < this.codeCount; i++) {\n            var bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    };\n    CompressorHuffmanTree.bitReverse = function (value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    };\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    CompressorHuffmanTree.prototype.getEncodedLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    };\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n        var maxCount;\n        var minCount;\n        var count;\n        var curLen = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    };\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n        var maxRepeatCount;\n        var minRepeatCount;\n        var currentRepeatCount;\n        var currentCodeLength = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    };\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildTree = function () {\n        var codesCount = this.codeFrequency.length;\n        var arrTree = new Int32Array(codesCount);\n        var treeLength = 0;\n        var maxCount = 0;\n        for (var n = 0; n < codesCount; n++) {\n            var freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                var pos = treeLength++;\n                var pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        var leafsCount = treeLength;\n        var nodesCount = leafsCount;\n        var child = new Int32Array(4 * treeLength - 2);\n        var values = new Int32Array(2 * treeLength - 1);\n        for (var i = 0; i < treeLength; i++) {\n            var node = arrTree[i];\n            var iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    };\n    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n        do {\n            var first = arrTree[0];\n            var last = arrTree[--treeLength];\n            var lastVal = values[last];\n            var pPos = 0;\n            var path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            var second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    };\n    CompressorHuffmanTree.prototype.buildLength = function (child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        var numNodes = Math.floor(child.length / 2);\n        var numLeafs = Math.floor((numNodes + 1) / 2);\n        var overflow = 0;\n        for (var i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        var iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    };\n    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        var nodePtr = 2 * numLeafs;\n        for (var bits = this.maxLength; bits !== 0; bits--) {\n            var n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                var childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    };\n    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n        var lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (var i = numNodes - 1; i >= 0; i--) {\n            var childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                var bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                var bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    };\n    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return CompressorHuffmanTree;\n}());\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n        var uint = new Uint32Array(1);\n        uint[0] = checksum;\n        var checksum_uint = uint[0];\n        var s1 = uint[0] = checksum_uint & 65535;\n        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    };\n    ChecksumCalculator.checkSumBitOffset = 16;\n    ChecksumCalculator.checksumBase = 65521;\n    ChecksumCalculator.checksumIterationCount = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n"]},"metadata":{},"sourceType":"module"}